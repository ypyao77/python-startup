#!/usr/bin/env python3
# -*- coding: utf-8 -*-


# 一开始， t1 和 t2 相等， 但是修改 t1 中的一个可变元素后， 二者不相等了

if __name__ == "__main__":
    # ❶ t1 不可变， 但是 t1[-1] 可变
    t1 = (1, 2, [30, 40])
    # ❷ 构建元组 t2， 它的元素与 t1 一样
    t2 = (1, 2, [30, 40])

    # ❸ 虽然 t1 和 t2 是不同的对象， 但是二者相等——与预期相符
    print("t1 == t2: {}".format(t1==t2))

    print("id(t1), id(t2): {}, {}".format(id(t1), id(t2)))

    # ❹ 查看 t1[-1] 列表的标识
    print("id(t1[-1]): {}".format(id(t1[-1])))

    # ❺ 就地修改 t1[-1] 列表
    t1[-1].append(99)
    print("t1: {}".format(t1))

    # ❻ t1[-1] 的标识没变， 只是值变了
    print("id(t1[-1]): {}".format(id(t1[-1])))

    # ❼ 现在， t1 和 t2 不相等
    print("t1 == t2: {}".format(t1 == t2))

    #
    # 复制列表（或多数内置的可变集合） 最简单的方式是使用内置的类型构造方法。
    l1 = [3, [55, 44], (7, 8, 9)]
    # ❶ list(l1) 创建 l1 的副本。
    l2 = list(l1)

    print("l1: {}".format(l1))
    print("l2: {}".format(l2))

    # ❷ 副本与源列表相等
    print("l1 == l2: {}".format(l1 == l2))

    # ❸ 但是二者指代不同的对象。 对列表和其他可变序列来说， 还能使用简洁的 l2 = l1[:] 语句创建副本
    print("l1 is l2: {}".format(l1 is l2))

    # 构造方法或 [:] 做的是浅复制（即复制了最外层容器， 副本中
    # 的元素是源容器中元素的引用） 。 如果所有元素都是不可变的， 那么这
    # 样没有问题， 还能节省内存。 但是， 如果有可变的元素， 可能就会导致
    # 意想不到的问题

    # 为一个包含另一个列表的列表做浅复制； 把这段代码复制粘贴到 Python Tutor 网站中， 看看动画效果

    l1 = [3, [66, 55, 44], (7, 8, 9)]
    # ❶ l2 是 l1 的浅复制副本
    l2 = list(l1)
    print('l1:', l1)
    print('l2:', l2)

    # ❷ 把 100 追加到 l1 中， 对 l2 没有影响
    l1.append(100)

    # ❸ 把内部列表 l1[1] 中的 55 删除。 这对 l2 有影响， 因为 l2[1] 绑定的列表与 l1[1] 是同一个
    l1[1].remove(55)
    print('l1:', l1)
    print('l2:', l2)

    # ❹ 对可变的对象来说， 如 l2[1] 引用的列表， += 运算符就地修改列表。 这次修改在 l1[1] 中也有体现， 因为它是 l2[1] 的别名
    l2[1] += [33, 22]
    # ❺ 对元组来说， += 运算符创建一个新元组， 然后重新绑定给变量
    # l2[2]。 这等同于 l2[2] = l2[2] + (10, 11)。 现在， l1 和 l2 中最
    # 后位置上的元组不是同一个对象。
    l2[2] += (10, 11)

    print('l1:', l1)
    print('l2:', l2)
